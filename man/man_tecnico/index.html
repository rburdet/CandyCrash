<!DOCTYPE HTML>
<html lang="es">

<head>
	<meta charset="utf-8">
	<title>Documentación Técnica</title>
	<link rel="stylesheet" href="estilos.css" />
</head>

<body>

<header>
<a href="Grupo 8" target="_blank"><img border="0" src="imagenes/fiuba.png"/></a>
<a href="Grupo 8" target="_blank" style="float:right;">Grupo 8</a>
</header>

<span id="version_producto">03/12/2013 18:00:00</span>

<div id="contenedor_general">

<span id="manual_tit">Documentación Técnica</span>

<article>
<span class="titulo">Contenidos</span>
<ol>

<li><a href="#Requerimientos_de_software" class="indice_entrada">Requerimientos de software</a></li>

<li><a href="#Descripción_general" class="indice_entrada">Descripción general</a></li>

<li><a href="#Servidor" class="indice_entrada">Servidor</a></li>

<li><a href="#Cliente" class="indice_entrada">Cliente</a></li>

<li><a href="#Editor" class="indice_entrada">Editor</a></li>

<li><a href="#Comunes" class="indice_entrada">Comunes</a></li>

<li><a href="#Código_fuente" class="indice_entrada">Código fuente</a></li>


</ol>
</article>

<article id="indice_">
<img id="indiceico" src="imagenes/indiceico.png" />
<div id="indice_margen"></div>
<span class="titulo">Contenidos</span>

	<div id="indice_scroll">
		<ol>
			<li><a href="#Requerimientos_de_software" class="indice_entrada">Requerimientos de software</a></li>

			<li><a href="#Descripción_general" class="indice_entrada">Descripción general</a></li>

			<li><a href="#Servidor" class="indice_entrada">Servidor</a></li>

			<li><a href="#Cliente" class="indice_entrada">Cliente</a></li>

			<li><a href="#Editor" class="indice_entrada">Editor</a></li>

			<li><a href="#Comunes" class="indice_entrada">Comunes</a></li>

			<li><a href="#Código_fuente" class="indice_entrada">Código fuente</a></li>


		<br>
		<br>
		<br>
		</ol>

	</div>

<script>
	var indices = document.getelementsbyclassname('indice_entrada');
	for(var i=0, ind; ind=indices[i]; i++){
		ind.innerhtml = ind.innerhtml.replace(/_/g, ' ');
	}
</script>
</article>

<!-- inicio contenido -->

<article id="Requerimientos_de_software">

<span class="titulo">1. Requerimientos de software</span>
<p>
El programa tendria que  ser corrido en cualquier distribución de Linux sin problemas. Especialmente fue probado en:
<ul>
	<li> Fedora 19 </li>
	<li> Ubuntu 13 </li>
	<li> Arch Linux </li>
	<li> Debian 7 </li> 
	<li> Peppermint </li> 
</ul>
Sin tener problema alguno en ninguno de ellos. 
</p>
<p>
Dependiendo de la distribución los paquetes necesarios para correr son:
Comunes a todas las distribuciones:
<ul>
	<li><strong> JsonCPP >= 0.6.0 </strong></li>
	<li><strong> Gtkmm 3.0 >= 3.8.1 </strong></li>
	<li><strong> libasound2 >= 1.0.27.2 </strong></li>
</ul>

Fedora / Red Hat / CentOS:
<ul> 
	<li> <strong> alsa-lib-devel </strong> Para reproducción de sonidos </li>
	<li> <strong> gtkmm30-devel.x86_64 </strong> Para compilar gtkmm en sistemas 64 bits</li> 
	<li> <strong> gtkmm30.x86_64 </strong> Para correr gtkmm en sistemas 64 bits</li>
	<li> <strong> gtkmm30-devel.i686 </strong>Para compilar gtkmm en sistemas 32 bits</li> 
	<li> <strong> gtkmm30.i686 </strong> Para correr gtkmm en sistemas 32 bits</li>
	<li> <strong> jsoncpp-devel.i686 </strong> Para compilar jsoncpp</li>
	<li> <strong> jsoncpp.i686 </strong> Para correr jsoncpp</li>
</ul>

Ubuntu / Peppermint / Debian:
<ul> 
	<li> <strong> libasound2 </strong> Para reproducción de sonidos </li>
	<li> <strong> libasound2-dev </strong> Para compilar sonidos </li>
	<li> <strong> libgtkmm-3.0-1 </strong> Para correr gtkmm </li>
	<li> <strong> libgtkmm-3.0-dev </strong>Para compilar gtkmm</li> 
	<li> <strong> libjsoncpp0 </strong>Para correr jsoncpp</li> 
	<li> <strong> libjsoncpp-dev </strong>Para compilar jsoncpp</li> 
</ul>
<div class="nota">
	<p>En sistemas Ubuntu o derivados es posible que se nececite agregar el ppa de <a href="https://launchpad.net/~gnome3-team/+archive/gnome3">GNOME 3 Team</a> para satisfacer las depedencias.</p>
</div>

Arch Linux:
<ul> 
	<li> <strong> extra/alsa-lib </strong> Para reproducción de sonidos </li>
	<li> <strong> extra/gtkmm3 </strong> Gtkmm </li>
	<li> <strong> extra/jsoncpp </strong>Para correr jsoncpp</li> 
</ul>
</p>

</article>


<article id="Descripción_general">

<span class="titulo">2. Descripción General</span> 
<p>
El producto se compone de 3 aplicaciones :
<ol>
	<strong>
		<li> Cliente </li>
		<li> Servidor </li>
		<li> Editor </li> 
	</strong>
</ol>
</p>
<p>El cliente es un juego de puzzle que se le entrega al cliente. Permite conectarse al servidor, crear partidas, y jugar. </p>
<p>El servidor es una aplicación de consola que acepta conexiones, recibe mensajes y organiza juegos permitiendo el caracter multijugador del producto. </p>
<p>El editor es una aplicación de desarrollo de niveles, que si bien puede ser entregada al cliente, fue pensada para ser usada por un Game Master, encargado de correr el servidor </p> 
<p> La diferenciación de código entre cliente/servidor se hace con el prefijo <i>cliente.</i>y <i>server.</i> respectivamente para cada uno de los archivos, aquellos archivos que son utilizados por tanto cliente como servidor contienen el prefijo <i>common.</i> .</p>

</article>



<article id="Servidor">
<span class="titulo">3. Servidor </span>
<span> A. Descripción general </span> 
<p>El servidor es una aplicación de linea de comandos que coordina la operación de los distintos clientes. Esta aplicación se encarga de toda la lógica del juego. Permite a los usuarios registrarse y conectarse, crear partidas, unirse a partidas, chatear entre ellos y por sobre todas las cosas es la que maneja el juego, ya que el cliente sólo sabe qué movimientos se hacen, todo lo demás corre por cuenta de esta aplicación que determinará si el movimiento es válido o no, en caso de serlo, realizará las modificaciones necesarias, computará los valores correspondientes a los combos hechos y reescribirá toda esta información a los distintos clientes en una misma partida para todas las partidas que se estén jugando.</p>
<p>Internamente el servidor ejecuta un thread que se queda escuchando las conecciones de los clientes, mientras que en el thread principal se usa para esperar la escritura de una letra 'q' para finalizar el proceso. El servidor crea un thread por cada cliente que se conecte.</p>

<span> B. Clases </span> 

<strong> Server </strong>
<p> Clase manejadora de conexiones, clientes y partidas. Implementa la interface <strong> ServerInterface </strong> </p>
<p> Métodos:
<ul>
		<li><strong>void removeClient(ThreadSocket* cli); </strong></li>
		<li><strong>PartidaInterface* newPartida(int nivel, std::string& nombre);</strong></li>
		<li><strong>void removePartida(PartidaInterface* p);</strong> Remueve partida de la lista</li>
		<li><strong>virtual void listPartidas(int nivel, Json::Value& parts);</strong> Devuelve un JSON con las partidas de nivel menor o igual al especificado.</li>
		<li><strong>virtual PartidaInterface* connectPartidas(long id);</strong></li>
		<li><strong>void end();	</strong></li>
	</ul>
</p>

<br>
<strong> Partida </strong>
<p> Clase que representa una partida. Implementa la interface <strong> PartidaInterface</strong> </p>
<p> Métodos:
<ul>
		<li><strong>void broadcastMsj(Json::Value& msj);</strong> Envia msj a todos los usuarios de la partida</li>
		<li><strong>void msjError(ThreadSocket* u, const char* msj);</strong> Envia un mensaje a u, (EVENT_GAME_MSG).</li>
		<li><strong>void msjError(ThreadSocket* u, const std::string& msj);</strong></li>
		<li><strong>Partida(ServerInterface* server, int nivel, std::string& nombre);</strong> Creador de la partida.</li>
		<li><strong>void addUsuario(ThreadSocket* u, Json::Value& user);</strong> Agre
		<li><strong>void rmUsuario(ThreadSocket* u);</strong>Borra un usuario de la partida</li>
</ul>
		 Metodos que devuelven informacion acerca de la partida
<ul>
	<li><strong>	int getNivel();</strong></li>
	<li><strong>	int getUsuarios();</strong></li>
	<li><strong>	int getMaxUsuarios();</strong></li>
	<li><strong>	PartidaEstado getEstado();</strong></li>
	<li><strong>std::string getNombre();</strong></li>
	<li><strong>virtual int mensaje(Json::Value& m, ThreadSocket* u); </strong>Metodo usado para mandarle mensajes a la partida.</li>
</ul>

</p>

<strong> Listador </strong>
<p> Clase encargada de obtener los niveles creados con su respectivo numero de  nivel </p>
<p> Métodos:
<ul>

		<li><strong>static Json::Value listar(); </strong>Devuelve un objeto (hash) con: { nombre de archivo : nivel del mapa, }</li>
		<li><strong>static int getNivel(std::string& fileName); </strong></li>
		<li><strong>static int getMapa(std::string& fileName, Json::Value& mapa); </strong></li>
	</ul>
</p>

<br>

<strong> TCPSocketListener </strong> 
<p> Clase heredera de TCPSocket encargada de recibir informacion de los clientes. </p>
<p> Métodos:
Los siguientes metodos escuchan a una nueva conexion
<ul>
	<li><strong>int listen(const int port);</strong></li>
	<li><strong>int listen(const int port, const std::string& ip);</strong></li>
	<li><strong>int listen(struct sockaddr_in & serv_addr);</strong></li>
</ul>
<ul>
	<li><strong>SocketIO* accept(); </strong> Acepta una nueva conexion, devuelve un file descriptor. Bloqueante </li>
	<li><strong>TCPSocketListener& setBacklog(const unsigned int backlog); </strong>Setea el backLog</li>
</ul>
</p>
<br>

<strong> ThreadUsuario </strong> 
<p> Clase heredera de ThreadSocket encargada de comunicar a cada usuario conectado. </p>
<p> Métodos para comunicarse con los clientes:
<ul>
	<li><strong>virtual int eventNoFirmado(Json::Value& data); </strong></li>
	<li><strong>virtual int eventFirmado(Json::Value& data);</strong></li>
	<li><strong>virtual void* subRun();</strong></li>
	<li><strong>int onJoinGame(Json::Value& data, Json::Value& userData);</strong></li>
	<li><strong>int onLeaveGame(Json::Value& data, Json::Value& userData);</strong></li>
	<li><strong>int onNewGame(Json::Value& data, Json::Value& userData);</strong></li>
	<li><strong>int onGetMaps(Json::Value& data, Json::Value& userData);</strong></li>
	<li><strong>int welcome();</strong></li>
</ul>
</p>
<br>

<strong> Tablero </strong> <p> Clase encargada de la logica del tablero </p> 
<p> Métodos:
<ul>
	<li><strong>void generar(); </strong> Genera el tablero a enviar a los jugadores </li>
	<li><strong> efectivizarCelda(Json::Value& celda);</strong> Pasa de las probabilidades a un caramelo en concreto</li>
	<li><strong>int movimiento(int x, int y, CaramelosMovimientos mov, Json::Value& movimientos, int maxPuntos);</strong> Ejecuta un movimiento. </li>
	<li><strong>bool hayMovimiento(int x, int y, Caramelos car);</strong> Devuelve verdadero si hay movimientos para realizar</li>
	<li><strong>void calcularCoordenadas(int x, int y, CaramelosMovimientos mov, int&xf, int &yf); </strong>Calcula las nuevas coordenadas dsp del movimiento </li>
	<li><strong>int doStar(Caramelos carameloMovido, int x, int y, Caramelos carameloMovido2, int xf, int yf, Json::Value& movimientos); </strong>Efectua accion de intercambio con star. </li>

	<li><strong>bool esMismoColor(Caramelos car, Caramelos car2);</strong></li>
	<li><strong>Json::Value newMov(int x, int y, CaramelosMovimientos mov);</strong>Crea la estructura de un movimiento para ser enviado.</li>
	<li><strong>Json::Value newMov(int x, int y, CaramelosMovimientos mov, Caramelos car);</strong></li>

	<li><strong>CaramelosMovimientos movInverso(CaramelosMovimientos mov);</strong>Invierte el movimiento pasado.</li>
	<li><strong>void rellenarTablero(Json::Value & movimientos);</strong>Rellena los casilleros vacios (RELLENAR), haciendo la caida de los caramelos de mas arriba</li>
	<li><strong>bool hayPatrones(Json::Value & movimientos, int & puntos);</strong>Busca si hay patrones y los reemplaza por RELLENAR, sumandole a puntos los puntos ganados. </li>
	<li><strong>bool esButton(Caramelos car);</strong></li>
</ul>
Metodos para activar combinaciones:
<ul>
	<li><strong>bool activarCombinacionColumna(int x, int y, bool todosButtons, int contador, Json::Value & movimientos, int &puntos,int x_mov, int y_mov); </strong></li>
	<li><strong>bool activarCombinacionColumna(int x, int y, bool todosButtons, int contador, Json::Value & movimientos, int &puntos);</strong></li>
	<li><strong>bool activarCombinacionFila(int x, int y, bool todosButtons, int contador, Json::Value & movimientos, int &puntos, int x_mov, int y_mov);</strong></li>
	<li><strong>bool activarCombinacionFila(int x, int y, bool todosButtons, int contador, Json::Value & movimientos, int &puntos);</strong></li>
	<li><strong>void dispararColumna(int x, Json::Value& movimientos, int puntosx, int& puntos);</strong></li>
	<li><strong>void dispararFila(int y, Json::Value& movimientos, int puntosx, int& puntos);</strong></li>
	<li><strong>int doCombinacion(Caramelos car, int x, int y, Json::Value& movimientos);</strong></li>
</ul>
<ul>
	<li><strong>Caramelos verBarColor(Caramelos car);</strong></li>
	<li><strong>Caramelos horBarColor(Caramelos car);</strong></li>
	<li><strong>Json::Value getTablero();</strong></li>	
	<li><strong>bool movimientoValido(int x, int y, CaramelosMovimientos mov);</strong></li>
</ul>
</p>
<br>

<span> C. Diagramas UML </span> 
<p>Los diagramas se adjuntaran por separado ya que fueron generados por Doxygen.</p>

<span> D. Descripción de archivos y procolos </span> 
<strong>Archivos utilizados:</strong>
<ul>
	<li><strong>user_data.json</strong> Archivo con la información de usuarios. Se crea si no existe.</li>
</ul>

<strong>Protocolo</strong>
<p>Para comunicación entre servidor cliente se realiza en formato JSON. Primero se envia un prefijo de longitud del mensaje, después el buffer de caracteres de información (encodeadas en Json) y por último la firma del mensaje. Estas firmas se realizaron utilizando la especificación <a href="http://en.wikipedia.org/wiki/Hmac">HMAC-MD5</a>.</p>
<p>Los mensajes de Json constan de un único campo obligatorio ( event ) que define el evento del mensaje. Este campo trae el valor de CommonEvent (enum definido en common.events.h) casteado a un int. Además, el mensaje puede traer campos de código de error (code), descripción del mensaje (msj) y otro datos pertenientes a mensajes específicos.</p>
<p>Ejemplo de mensaje de login:</p>
<pre>
<code>
{
	"event": 1,
	"user": ...,
	"code": 0
}
</code>
</pre>

<p>Todos los mensajes relacionados con el juego en sí mismo llevan el evento "EVENT_GAME_MISC", y llevaran otro campo "ev-game" para indicar de que tipo de evento es el mensaje.</p>
<p>Ejemplo de menaje de chat dentro de juego:</p>
<pre>
<code>
{
	"event": 8,
	"ev-game": 10,
	"msj": "mensaje",
	"code": 0
}
</code>
</pre>

<div class="nota">
	<p>En los ejemplos Json, se pone el número que representaría el enum CommonEvent casteado a un entero. Este valor podrá cambiar en futuras versiones. Es recomendable siempre usar el nombre que tiene el enum, ej: EVENT_LOGIN, EVENT_GAME_MISC, </p>
</div>


<article id="Cliente">
<span class="titulo">4. Cliente </span>
<span> A. Descripción general </span> 
<p> Aplicación entregada al cliente. Consiste en un juego de puzzle multijugador donde cada jugador debe competir contra otros en tiempo real para demostrar quien de todos es el más apto al momento de hacer combinaciones de colores y fichas. </p>
<p> Este programa interactúa todo el tiempo con el servidor, enviandole información firmada, para que este la procese, y responda. La información (en formatos JSon) se encripta utilizando HMAC, se envía al servidor, el cual es, en teoría, el único capaz de descifrarla. </p>
<p> El cliente utiliza solo dos threads, el principal que es ocupado por el main del gtk y uno que se crea después de establecer la conección con el servidor. Este último esta constantemente escuchando mensajes que podría recibir del servidor. Como solo se pueden ejecutar métodos de gtk dentro del thread de gtk, ambos threads comparten una cola de mensajes. El thread que esta a la escucha, escribe todos los mensajes a esta cola, el thread de gtk ejecuta una función cada una determinada cantidad de tiempo para revisar si hay nuevos mensajes en esta cola.</p>

<span> B. Clases </span> 

<strong> Caramelo </strong>
<p> Clase abstracta de la que heredan todos los distintos tipos de caramelos </p>
<p> Métodos:
<ul>
	<li><strong>Caramelo (int idCaramelo, const std::string &imageName, int i, int j) </strong></li>
	<li><strong>bool mover (int x, int y) </strong></li>
	<li><strong>bool mover ()</strong></li>
	<li><strong>bool setMoviendo (bool moviendo, int x, int y)</strong></li>
	<li><strong>bool setMoviendo (bool moviendo)</strong></li>
	<li><strong>int getId ()</strong></li>
	<li><strong>void opacar ()</strong></li>
	<li><strong>bool visible ()</strong></li>
	<li><strong>bool fullyVisible ()</strong></li>
	<li><strong>void hacerAparecer ()</strong></li>
	<li><strong>int getX ()</strong></li>
	<li><strong>int	getXPos ()</strong></li>
	<li><strong>int getY ()</strong></li>
	<li><strong>int getYPos ()</strong></li>
	<li><strong>void setX (int x)</strong> Pone la posicion en X </li>
	<li><strong>void setXPos (int x)</strong> Pone la posicion en X en el tablero</li>
	<li><strong>void setY (int y)</strong> Pone la posicion en Y</li>
	<li><strong>void setYPos (int y)</strong> Pone la posicion en Y en el tablero</li>
</ul>
</p>
<br>

Tanto <strong> Bar </strong> como <strong> Button </strong> y <strong> Star </strong> heredan de caramelo con sus mismos metodos pero distintas propiedades.
<br>

<strong> Cliente </strong>
<p> Clase que modela a un cliente. Implementa la interfaz <strong> ClienteInterface </strong>  </p>
<p> Métodos:
<ul>
	<li><strong>bool onTimeout(); </strong></li>
	<li><strong>void onLogin(int code, Json::Value& data); </strong></li>
	<li><strong>void onLogout(int code, Json::Value& data);</strong></li>
	<li><strong>void onGame(int code, Json::Value& data);</strong></li>
	<li><strong>void conectar(std::string ip, std::string user, std::string pass, bool check);</strong></li>
	<li><strong>void sendMsj(Json::Value data);</strong></li>
	<li><strong>virtual void nuevoMensaje(Json::Value& msj);</strong></li>
</ul>
</p>
<br>

<strong> CandyFactory </strong>
<p> Clase constructora de caramelos. Implementa el patron de diseno de Factory</p>
<p> Método:
<ul>
	<li><strong>static Caramelo* crearCaramelo(int id,int i,int j)</strong> Devuelve un caramelo con su informacion lista</li>
</ul>
</p>
<br>

<strong> Window </strong>
<p> Clase abstracta de la que heredan todas las ventanas del cliente</p>
<p> Métodos:
<ul>
	<li><strong>bool dialog(const std::string& pri, const std::string& sec)</strong></li>
	<li><strong>bool dialog(const char* pri, const char* sec)</strong></li>
	<li><strong>void set_background_image(std::string path)</strong></li>
	<li><strong>virtual bool onClose()</strong> Despliega una ventana de confirmacion al cerrar</li>
	<li><strong>void on_about()</strong> Despliga informacion de la aplicacion</li>
	<li><strong>void on_desconectar();</strong> Despliega ventana de confirmacion de desconexion, tambien desconecta</li>
	<li><strong>virtual bool onClose();</strong> Cierra la ventana</li>
	<li><strong>virtual void mensaje(Json::Value& data)</strong> Mensaje que manda cada ventana</li>
</ul>
</p>
<br>


<strong> GameWindow </strong>
<p> Ventana previa al juego. Hereda de Window</p>
<p> Métodos:
<ul>
	<li><strong>void on_mensaje();</strong></li>
		<li><strong>void on_start_game();</strong></li>
		<li><strong>void on_salir_game();</strong></li>
		<li><strong>void on_tablero_mensaje(Json::Value data);</strong></li>
		<li><strong>void on_salir();</strong></li>
		<li><strong>void on_desconectar();</strong></li>
		<li><strong>virtual bool onClose();</strong></li>
</ul>
</p>
<br>

<strong> MainWindow </strong>
<p> Ventana de creacion o eleccion de partidas, segunda en el orden de aparicion. Hereda de Window</p>
<p> Métodos:
<ul>
		<li><strong>void on_partidas(); </strong>  Handler del actualizador de la lista de partidas</li>
		<li><strong>void join_partidas(); </strong> Se una a una partida</li>
		<li><strong>void on_mapas();</strong>Actualizador de lista de mapas </li>
		<li><strong>void on_crear_partida();</strong>Crea partida</li>
</ul>
</p>
<br>

<strong> IpWindow </strong>
<p> Primera Ventana del juego. Hereda de Window</p>
<p> Métodos:
<ul>
	<li><strong>void on_mensaje();</strong></li>
		<li><strong>void on_start_game();</strong></li>
		<li><strong>void on_salir_game();</strong></li>
		<li><strong>void on_tablero_mensaje(Json::Value data);</strong></li>
		<li><strong>void on_salir();</strong></li>
		<li><strong>void on_desconectar();</strong></li>
		<li><strong>virtual bool onClose();</strong></li>
</ul>
</p>
<br>


<strong> TCPSocketConnect </strong>
<p> Clase encapsulante de sockets. Hereda de TCPSocket y SocketIO</p>
<p> Métodos para conectarse:
<ul>
	<li><strong>int connect(const std::string& ip);</strong></li>
	<li><strong>int connect(const int port, const std::string& ip);</strong></li>
	<li><strong>int connect(struct sockaddr_in & serv_addr);</strong></li>
</p>
<br>

<strong> ThreadListener </strong>
<p>Thread que se encarga de leer constantemente al socket. De recibir algun mensaje lo agrega a la cola de mensajes del cliente. Hereda de ThreadSocket</p>
<p> Métodos para conectarse:
<ul>
		<li><strong>virtual int eventNoFirmado(Json::Value& data);</strong></li>
		<li><strong>virtual int eventFirmado(Json::Value& data);</strong></li>
		<li><strong>virtual void* subRun();</strong></li>
		<li><strong>void setKey(std::string&key);</strong> Setea la clave usada para la firma digital de los paquetes </li>
</ul>
</p>
<br>



<strong> SoundPlayer </strong>
<p> Clase para reproducir sonidos</p>
<p> Métodos utilizados para reproducir:
<ul>
		<li><strong>static bool play_wave(const std::string& str);</strong></li>
		<li><strong>void thread_play(int fd, int sample_rate, int seconds);</strong></li>
		<li><strong>static void* wav_runner(void* arg);</strong></li>
		<li><strong>static bool play(const std::string& str);</strong></li>
		<li><strong>static bool play(const char* str);</strong></li>
</ul>
</p>
<br>

<span> C. Diagramas UML </span> 
Los diagramas se adjuntaran por separado ya que fueron generados por Doxygen.

<span> D. Descripción de archivos y procolos </span> 
<strong>Archivos utilizados:</strong>
<ul>
	<li><strong>../imagenes/</strong> Carpeta que contiene imágenes y archivos de estilo</li>
	<li><strong>../imagenes/style.css</strong> Estilo css del programa</li>
</ul>

<strong>Protocolo</strong>
<p>El cliente y el servidor envian y reciben mensajes con el mismo protocolo y forma. Ver la sección de protocolo del servidor.</p>

</article>

<article id="Editor">
<span class="titulo">5. Editor</span>

<span> A. Descripción general </span> 
<p> Esta aplicación es un editor de nivel, con la cual se puede crear fácilmente cualquier nivel y con cualquier de las características que se quieran. Fue diseñada con Glade 3 lo que provocó que no se haya podido usar cierta herencia en la creación del modelo.
Son 3 las cosas más importantes de esta aplicación. Arriba a la izquierda se encuentra el frame de opciones básicas, donde se configura el nivel. Por debajo el box de probabilidades e imagenes. A la derecha el tablero con el cual se interactúa para volcarle la información necesaria.

<span> B. Clases </span> 
<strong> BarraEstado </strong>
<p> Clase utilizada para mostrar mensajes en un status bar debajo a la derecha</p>
<p> Métodos:
<ul>
		<li><strong>onMostrar(Gtk::Entry* entryArchivo)</strong> Muestra lo que tenga entryArchivo en el statusBar</li> 
</ul>
</p>
<br>

<strong> BoxOpcionesBasicas </strong>
<p> Clase contenedora de opciones básicas</p>
<p> Métodos:
<ul>
	<li><strong>std::string getNombre(); </strong></li>
	<li><strong>double getPuntaje();</strong></li>
	<li><strong>double getJugadoresMax();</strong></li>
	<li><strong>int getDimX()</strong></li>;
	<li><strong>int getDimY();</strong></li>
	<li><strong>int getNivel();</strong></li>
</ul>
</p>
<br>


<strong> Celda </strong>
<p> Clase que modela una Celda</p>
<p> Métodos:
<ul>
		<li><strong>int getX(); </strong></li>
		<li><strong>int getY();</strong></li>
		<li><strong>Info* getInfo();</strong></li>
		<li><strong>void on_adj_changed(Gtk::SpinButton* spinbutton,int id);</strong> Al cambiar un spinbutton, se setea la probabilidad del caramelo correspondiente en esta celda</li>
		<li><strong>void setImage(const std::string& fileName);</strong></li>
		<li><strong>void setHueco();</strong></li>
		<li><strong>bool isHueco();</strong></li>
		<li><strong>std::string getImage();	</strong></li>
</ul>
</p>
<br>


<strong> Columna </strong>
<p> Clase que modela una Columna</p>
<p> Métodos :
<ul>
		<li><strong>void on_adj_changed(Gtk::SpinButton* spinbutton,int id);</strong>Al cambiar un spinbutton, se setea la probabilidad del caramelo correspondiente en esta columna</li>
		<li><strong>Gtk::Button* get_boton();</strong></li>
		<li><strong>Info* getInfo();</strong></li>
</ul>
</p>
<br>



<strong> Probs </strong>
<p> Clase contenedora de widgets para probabilidades</p>
<p> Métodos:
<ul>
		<li><strong>void cargarBotones(Glib::RefPtr<Gtk::Builder>& builder, int firstbutton, int lastbutton); </strong> Carga los botones del archivo de glade</li>
</ul>
</p>
<br>

<strong> Info </strong>
<p> Clase que contiene probabilidades</p>
<p> Métodos :
<ul>
		<li><strong>void setProb_piezas(int prob,int x);</strong></li>
		<li><strong>int getProb_piezas(int idx);</strong></li>
		<li><strong>int* getArray();</strong></li>
</ul>
</p>
<br>



<strong> MainWindow </strong>
<p> Clase que modela la ventana principal</p>
<p> Métodos:
<ul>
	<li><strong>Gtk::Window* getMainWindow(); </strong> Devuelve la instancia de ventana creada </li>
	<li><strong>void cerrar(); </strong> </li>
</ul>
</p>
<br>



<strong> Menu </strong>
<p> Menu bar para la ventana</p>
<p> Métodos:
<ul>
		<li><strong>void displayHelp</strong> Muestra el Help</li>
		<li><strong>void displayAbout</strong>Muestra el About</li>
</ul>
</p>
<br>



<strong> Persistidor </strong>
<p> Clase encargada de persistir el mapa</p>
<p> Método:
<ul>
		<li><strong>static void persistir(Json::Value& nivel,const std::string& nombre)</strong> Persiste el mapa</li>
</ul>
</p>
<br>



<p>Tanto <strong> ProbCeldas </strong> como <strong> ProbColumnas </strong> solo tienen un método constructor, que levanta las widgets del archivo de glade y conectan todas las señales. </p>

<br>
<strong> Tablero </strong>
<p> Clase que modela el tablero</p>
<p> Métodos:
<ul>
	<li><strong>void on_adjCols_changed_tablero (Gtk::SpinButton *spinbutton, int id) </strong></li>
	<li><strong>void on_cordx_changed (Gtk::SpinButton *spin_x)</strong></li>
	<li><strong>void on_cordy_changed (Gtk::SpinButton *spin_y)</strong></li>
	<li><strong>void on_adj_changed_tablero (Gtk::SpinButton *spinbutton, int id)</strong></li>
	<li><strong>void on_image_changed_tablero (Gtk::FileChooser *fileChooser)</strong></li>
	<li><strong>void on_image_fondo_changed_tablero (Gtk::FileChooser *fileChooser)</strong></li>
	<li><strong>void on_check_button_tablero ()</strong></li>
	<li><strong>void jsonCeldas (Json::Value &nivel, const std::string &nombre)</strong></li>
	<li><strong>void jsonColumnas (Json::Value &nivel, const std::string &nombre)</strong></li>
</ul>
</p>
<br>


<span> C. Diagramas UML </span> 
Los diagramas se adjuntaran por separado ya que fueron generados por Doxygen.

<span> D. Descripción de archivos y procolos </span> 
<p> Cuando un mapa se genera lo hace con la extension .map . Estos mapas estan en formato Json y tienen la siguiente forma (no se explicita todo el mapa para mayor prolijidad):
<pre>
<code>
{
	"nombre_de_mapa" : 
	{
		"DIM" : 
		{
			"X" : numero_filas,
			"Y" : numero_columnas
		},
		"celdas" : 
		{
			"0" : 
			{
				"0" : 
				{
					"fondo" : "",
					"probabilidades" : [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
				},
				"numero_filas" : 
				{
					"fondo" : "",
					"probabilidades" : [ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
				},
			"numero_columnas" :
			{
				"0" : ....
			},
		},
		"columnas" :
		{
			"0" : [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
			"numero_columnas" : [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
		},
		"fondo" : "../imagenes/fondo.jpg",
		"max_jugadores" : 3,
		"nivel" : 2,
		"puntaje_para_ganar" : 10000
	}
}
</code>
</pre>

<article id="Comunes">
<span class="titulo">6. Comunes </span>
<p> A continuacion se detallan los archivos comunes utilizados tanto por cliente como por servidor:
<ul>
	<li><strong>common.caramelos.h</strong></li>
	<li><strong>common.caramelos_movimientos.h	</strong></li>
	<li><strong>common.events.h	</strong></li>
	<li><strong>common.hmac.h	</strong></li>
	<li><strong>common.logger.h	</strong></li>
	<li><strong>common.md5.h	</strong></li>
	<li><strong>common.mutex.h	</strong></li>
	<li><strong>common.socket.h	</strong></li>
	<li><strong>common.socket_io.h	</strong></li>
	<li><strong>common.thread.h	</strong></li>
	<li><strong>common.thread_socket.h	</strong></li>
	<li><strong>common.user_manager.h</strong></li>
</ul>
<br> 
Todas sus declaraciones pueden ser vistas en el archivo generado por Doxygen 
</p>

</article>

<article id="Código_fuente">
<span class="titulo">6. Código fuente</span>
<p> El código fuente del proyecto será adjuntado para mayor claridad </p>

</article>
<!-- fin de contenido -->

</div><!-- cierre contenedor_general -->

</body>
</html>
